---
phase: 04-state-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/arios-cli/src/types/state.ts
  - packages/arios-cli/src/utils/state.ts
  - packages/arios-cli/package.json
autonomous: true

must_haves:
  truths:
    - "State can be read from .planning/STATE.md with YAML frontmatter"
    - "State can be written atomically (no corruption on crash)"
    - "Conflict detection identifies when state was modified externally"
    - "Checksum validation detects meaningful state changes"
  artifacts:
    - path: "packages/arios-cli/src/types/state.ts"
      provides: "ProjectState, DecisionRecord, StateConflict types"
      exports: ["ProjectState", "DecisionRecord", "StateConflict"]
    - path: "packages/arios-cli/src/utils/state.ts"
      provides: "State load/save with conflict detection"
      exports: ["loadProjectState", "saveProjectState", "detectConflict"]
  key_links:
    - from: "packages/arios-cli/src/utils/state.ts"
      to: "gray-matter"
      via: "YAML frontmatter parsing"
      pattern: "matter\\("
    - from: "packages/arios-cli/src/utils/state.ts"
      to: "crypto"
      via: "MD5 checksum for conflict detection"
      pattern: "createHash\\('md5'\\)"
---

<objective>
Create the state persistence layer with typed project state, atomic file operations, and conflict detection.

Purpose: Enable session continuity by persisting project state in .planning/STATE.md with YAML frontmatter (matching existing ARIOS handoff patterns).

Output: TypeScript types and utility functions for state management that other ARIOS components can import.
</objective>

<execution_context>
@/Users/j.franke/.claude/get-shit-done/workflows/execute-plan.md
@/Users/j.franke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-state-management/04-CONTEXT.md
@.planning/phases/04-state-management/04-RESEARCH.md

# Existing patterns to follow
@packages/arios-cli/src/types/handoff.ts
@packages/arios-cli/src/utils/handoff.ts
@packages/arios-cli/src/utils/files.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state types</name>
  <files>packages/arios-cli/src/types/state.ts</files>
  <action>
Create state types following the established handoff.ts type alias pattern (NOT interfaces per 02-01 decision).

Include these types:

```typescript
// Phase status
type PhaseStatus = 'not-started' | 'in-progress' | 'complete' | 'blocked';

// Decision record (positive AND negative per CONTEXT.md)
type DecisionRecord = {
  id: string;
  decision: string;
  reasoning: string;
  phase: string;
  date: string;
  rejected?: boolean;  // true for negative decisions
};

// State frontmatter (matches YAML frontmatter in STATE.md)
type StateFrontmatter = {
  version: string;        // Schema version for migrations
  phase: number;          // Current phase number
  planIndex: number;      // Current plan within phase
  totalPhases: number;    // Total phases in project
  totalPlans: number;     // Total plans in current phase
  status: PhaseStatus;
  lastActivity: string;   // ISO date YYYY-MM-DD
  checksum: string;       // MD5 hash for conflict detection
};

// Full project state file
type ProjectState = {
  frontmatter: StateFrontmatter;
  decisions: DecisionRecord[];
  body: string;  // Human-readable markdown content
};

// Conflict detection result
type StateConflict = {
  hasConflict: boolean;
  expectedChecksum: string;
  actualChecksum: string;
  message: string;
};
```

Export all types. Follow the JSDoc style from handoff.ts for documentation.
  </action>
  <verify>
Run `npx tsc --noEmit` from packages/arios-cli - no type errors.
Verify exports: `grep -c "export type" packages/arios-cli/src/types/state.ts` returns 5+
  </verify>
  <done>
State types exist and compile without errors. Types follow established patterns from handoff.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create state utilities</name>
  <files>packages/arios-cli/src/utils/state.ts</files>
  <action>
Create state utilities following the handoff.ts pattern. Use gray-matter for YAML frontmatter (already installed), crypto for checksums.

Implement these functions:

1. `calculateChecksum(frontmatter: StateFrontmatter): string`
   - Hash only meaningful fields (phase, planIndex, status, decisions)
   - Exclude checksum and lastActivity from hash (metadata, not state)
   - Use MD5, return first 8 chars (sufficient for conflict detection)

2. `loadProjectState(statePath: string): Promise<{ state: ProjectState | null; conflict: StateConflict | null }>`
   - Read file with gray-matter
   - Parse frontmatter as StateFrontmatter
   - Parse decisions from body (YAML list or extract from markdown)
   - Calculate current checksum and compare to stored
   - Return conflict object if mismatch
   - Return null state if file doesn't exist (not an error)

3. `saveProjectState(statePath: string, state: ProjectState): Promise<void>`
   - Calculate new checksum
   - Update lastActivity to current date
   - Use atomic write pattern: write to .tmp, then rename
   - Ensure parent directory exists

4. `formatStateMarkdown(state: ProjectState): string`
   - Format decisions as bullet list in body
   - Include mini status table
   - Keep format human-readable (will be viewed by users)

Use node:crypto for hashing (built-in, no dependency needed).
Follow error handling pattern from handoff.ts (let ENOENT return null, rethrow others).
  </action>
  <verify>
Run `npx tsc --noEmit` from packages/arios-cli - no type errors.
Verify exports: `grep "export async function\|export function" packages/arios-cli/src/utils/state.ts`
  </verify>
  <done>
State utilities compile and export loadProjectState, saveProjectState, calculateChecksum, formatStateMarkdown.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add index exports</name>
  <files>packages/arios-cli/src/types/state.ts, packages/arios-cli/src/utils/state.ts</files>
  <action>
Ensure the new modules integrate with the package structure:

1. Verify types/state.ts is importable (ESM with .js extension in imports)
2. Verify utils/state.ts imports from '../types/state.js' (not .ts)
3. Test the build works: `npm run build` in packages/arios-cli

No need to modify index.ts unless it has explicit re-exports (check first).
  </action>
  <verify>
Run `npm run build` from packages/arios-cli - builds successfully.
Check dist/ contains state.js files in both types/ and utils/.
  </verify>
  <done>
Package builds successfully with new state modules included in dist/.
  </done>
</task>

</tasks>

<verification>
1. `cd packages/arios-cli && npm run build` succeeds
2. `ls packages/arios-cli/dist/types/state.js` exists
3. `ls packages/arios-cli/dist/utils/state.js` exists
4. Types compile without errors
5. Functions follow atomic write pattern
</verification>

<success_criteria>
- State types defined matching CONTEXT.md decisions (including negative decisions)
- Load/save functions work with .planning/STATE.md format
- Checksum-based conflict detection implemented
- Atomic writes prevent corruption
- All code compiles and builds
</success_criteria>

<output>
After completion, create `.planning/phases/04-state-management/04-01-SUMMARY.md`
</output>
