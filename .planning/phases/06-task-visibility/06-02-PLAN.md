---
phase: 06-task-visibility
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - packages/arios-dashboard/src/server/watcher.ts
  - packages/arios-dashboard/src/server/parser.ts
autonomous: true

must_haves:
  truths:
    - "File changes in .planning directory trigger SSE broadcasts"
    - "PLAN.md files are parsed into Task objects with status"
    - "SUMMARY.md files update task completion status"
    - "STATE.md is parsed for current position"
    - "ROADMAP.md content is captured for rendering"
  artifacts:
    - path: "packages/arios-dashboard/src/server/watcher.ts"
      provides: "Chokidar file watcher for .planning directory"
      exports: ["createWatcher"]
    - path: "packages/arios-dashboard/src/server/parser.ts"
      provides: "Parsing logic for all .planning file types"
      exports: ["parseFile", "parseAllFiles", "buildDashboardState"]
  key_links:
    - from: "packages/arios-dashboard/src/server/watcher.ts"
      to: "packages/arios-dashboard/src/server/parser.ts"
      via: "parseFile call on file change"
      pattern: "parseFile\\("
    - from: "packages/arios-dashboard/src/server/watcher.ts"
      to: "chokidar"
      via: "watch call"
      pattern: "chokidar\\.watch"
---

<objective>
Implement file watching and parsing to detect changes in .planning directory and convert markdown files into typed dashboard data.

Purpose: This is the data pipeline that powers real-time updates. File changes trigger parsing, which produces typed data that gets broadcast via SSE to connected browsers.
Output: Working file watcher that parses .planning files and broadcasts changes.
</objective>

<execution_context>
@/Users/j.franke/.claude/get-shit-done/workflows/execute-plan.md
@/Users/j.franke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-task-visibility/06-CONTEXT.md
@.planning/phases/06-task-visibility/06-RESEARCH.md
@packages/arios-dashboard/src/types/dashboard.ts
@packages/arios-dashboard/src/server/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement file parser for .planning files</name>
  <files>packages/arios-dashboard/src/server/parser.ts</files>
  <action>
Create parser module using gray-matter for frontmatter extraction:

1. parseFile(filePath: string): Task | Phase | DashboardState | null
   - Detect file type from path:
     - `*-PLAN.md` -> parse as Task
     - `*-SUMMARY.md` -> parse as completion data
     - `STATE.md` -> parse as state position
     - `ROADMAP.md` -> capture raw content
   - Return null for unrecognized files

2. parsePlanFile(filePath: string, content: string): Task
   - Use gray-matter to extract frontmatter
   - Extract: phase, plan, wave, depends_on, files_modified
   - Determine status:
     - If corresponding SUMMARY.md exists -> 'complete'
     - If matches STATE.md current plan -> 'in-progress'
     - Otherwise -> 'pending'
   - Extract name from <objective> section (first line after tag)
   - Build id as "{phaseNum}-{planNum}" padded (e.g., "05-01")

3. parseSummaryFile(filePath: string, content: string): Partial<Task>
   - Extract: duration, completed date
   - Return data to merge with task

4. parseStateFile(content: string): { currentPhase: number, currentPlan: number }
   - Extract phase, planIndex from frontmatter

5. parseRoadmapFile(content: string): { phases: Phase[], roadmap: string }
   - Parse phase list with completion status
   - Return raw content for marked rendering in browser

6. buildDashboardState(planningDir: string): DashboardState
   - Scan all files in planningDir
   - Build complete state object
   - Used for initial SSE connection

7. parseAllFiles(planningDir: string): Map<string, Task | Phase>
   - Utility to load all tasks and phases into a map
  </action>
  <verify>
    Create test script that runs parser on .planning directory:
    `cd packages/arios-dashboard && echo "import { buildDashboardState } from './src/server/parser.js'; console.log(JSON.stringify(await buildDashboardState('../../.planning'), null, 2));" > test-parser.mjs && npx tsx test-parser.mjs | head -50`
  </verify>
  <done>Parser extracts tasks, phases, and state from all .planning file types</done>
</task>

<task type="auto">
  <name>Task 2: Implement Chokidar file watcher</name>
  <files>packages/arios-dashboard/src/server/watcher.ts</files>
  <action>
Create file watcher using Chokidar per RESEARCH.md patterns:

1. createWatcher(planningDir: string, onStateChange: (state: DashboardState) => void): FSWatcher
   - Watch planningDir recursively (depth: 5 for phases/XX-name/files)
   - Ignore dotfiles except .planning itself
   - Enable awaitWriteFinish: { stabilityThreshold: 300, pollInterval: 100 }
   - ignoreInitial: false to emit events for existing files

2. Event handling:
   - on('add', path): Parse file, update internal state, call onStateChange
   - on('change', path): Same as add
   - on('unlink', path): Remove from internal state, call onStateChange
   - on('ready'): Log "Initial scan complete", build full state
   - on('error', error): Log error, continue watching

3. Internal state management:
   - Maintain Map<string, Task> for tasks
   - Maintain state position (currentPhase, currentPlan)
   - Maintain roadmap content
   - On any change, rebuild DashboardState and call onStateChange

4. Debounce rapid changes:
   - Use 100ms debounce before calling onStateChange
   - Prevents SSE spam during wave execution

5. Export function returns FSWatcher for cleanup on server shutdown
  </action>
  <verify>
    Add watcher integration test to server:
    Start server, modify a file in .planning, check SSE client receives update.
    Manual test: `curl -N http://localhost:3456/events &` then `touch .planning/STATE.md` and observe event output.
  </verify>
  <done>File watcher detects changes and triggers state updates with debouncing</done>
</task>

<task type="auto">
  <name>Task 3: Wire watcher into server SSE broadcast</name>
  <files>
    packages/arios-dashboard/src/server/index.ts
    packages/arios-dashboard/src/server/watcher.ts
  </files>
  <action>
Update server/index.ts to integrate watcher:

1. Import createWatcher from ./watcher.js
2. Import buildDashboardState from ./parser.js

3. In startServer:
   - Create watcher with planningDir parameter
   - Pass broadcast function as onStateChange callback:
     ```typescript
     const watcher = createWatcher(planningDir, (state) => {
       broadcast({ type: 'update', payload: state });
     });
     ```

4. On new SSE connection:
   - Build initial state via buildDashboardState
   - Send as initial message: { type: 'initial', payload: state }

5. Graceful shutdown:
   - Export stopServer() that closes watcher and HTTP server
   - Handle SIGINT/SIGTERM for clean exit

6. Update startServer signature:
   ```typescript
   export async function startServer(planningDir: string): Promise<{
     port: number;
     stop: () => Promise<void>;
   }>
   ```
  </action>
  <verify>
    Full integration test:
    1. Start server pointing at .planning
    2. Connect SSE client, verify initial state received
    3. Touch a PLAN.md file, verify update event received
    4. Stop server, verify clean shutdown
  </verify>
  <done>Server broadcasts file changes via SSE with initial state on connection</done>
</task>

</tasks>

<verification>
1. `cd packages/arios-dashboard && npx tsc --noEmit` - TypeScript compiles
2. Parser correctly extracts data from existing .planning files
3. Watcher detects file changes with debouncing
4. SSE endpoint sends initial state on connection
5. File changes trigger SSE update broadcasts
</verification>

<success_criteria>
- Parser extracts Task objects from PLAN.md frontmatter
- Parser determines task status from SUMMARY.md existence
- Parser extracts state position from STATE.md
- Watcher detects add/change/unlink events in .planning
- Watcher debounces rapid changes (100ms)
- SSE clients receive initial state snapshot on connect
- SSE clients receive updates when files change
</success_criteria>

<output>
After completion, create `.planning/phases/06-task-visibility/06-02-SUMMARY.md`
</output>
