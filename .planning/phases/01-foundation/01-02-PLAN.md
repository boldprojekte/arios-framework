---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/arios-cli/src/commands/init.ts
  - packages/arios-cli/src/commands/update.ts
  - packages/arios-cli/src/utils/files.ts
  - packages/arios-cli/src/utils/templates.ts
  - packages/arios-cli/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Running `npx arios init` in an empty directory creates .arios/ and .claude/commands/arios/"
    - "CLAUDE.md is created or updated with ARIOS section"
    - "Config file stores project name and defaults"
    - "CLI provides colored output and spinners for feedback"
  artifacts:
    - path: "packages/arios-cli/src/commands/init.ts"
      provides: "Init command implementation"
      exports: ["init"]
      min_lines: 40
    - path: "packages/arios-cli/src/commands/update.ts"
      provides: "Update command implementation (placeholder)"
      exports: ["update"]
    - path: "packages/arios-cli/src/utils/files.ts"
      provides: "File system utilities"
      exports: ["copyTemplates", "ensureDir"]
    - path: "packages/arios-cli/src/utils/templates.ts"
      provides: "Handlebars template rendering"
      exports: ["renderTemplate"]
  key_links:
    - from: "packages/arios-cli/src/index.ts"
      to: "packages/arios-cli/src/commands/init.ts"
      via: "import and command registration"
      pattern: "import.*init.*from.*commands/init"
    - from: "packages/arios-cli/src/commands/init.ts"
      to: "packages/arios-cli/templates/"
      via: "template copying"
      pattern: "copyTemplates|fs.*copy"
---

<objective>
Implement the init and update commands that install ARIOS into user projects.

Purpose: Make `npx arios init` functional - it should create all necessary ARIOS files in a project directory with zero configuration required.

Output: Working CLI commands that copy templates, render handlebars variables, and update CLAUDE.md.
</objective>

<execution_context>
@/Users/j.franke/.claude/get-shit-done/workflows/execute-plan.md
@/Users/j.franke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create utility modules</name>
  <files>
    packages/arios-cli/src/utils/files.ts
    packages/arios-cli/src/utils/templates.ts
  </files>
  <action>
Create reusable utilities for file operations and template rendering:

1. **src/utils/files.ts** - File system operations:
   - `ensureDir(path: string)`: Create directory if it doesn't exist (use fs-extra)
   - `copyTemplates(srcDir: string, destDir: string, options?: { exclude?: string[] })`: Copy template directory recursively, exclude .hbs files (those go through template rendering)
   - `fileExists(path: string)`: Check if file exists
   - `readFile(path: string)`: Read file as string
   - `writeFile(path: string, content: string)`: Write string to file

2. **src/utils/templates.ts** - Handlebars template rendering:
   - `renderTemplate(templatePath: string, data: Record<string, unknown>)`: Read .hbs file, render with Handlebars, return string
   - `renderTemplateToFile(templatePath: string, destPath: string, data: Record<string, unknown>)`: Render and write in one step
   - Note: We're using simple string replacement for now, not full Handlebars. Replace {{variableName}} patterns. Add Handlebars later if needed.

Both modules should use ESM imports and export named functions. Use fs-extra for file operations. Handle errors gracefully with try/catch.
  </action>
  <verify>
    - src/utils/files.ts exports ensureDir, copyTemplates, fileExists
    - src/utils/templates.ts exports renderTemplate, renderTemplateToFile
    - No TypeScript errors (check with: npx tsc --noEmit)
  </verify>
  <done>Utility modules ready for use by commands</done>
</task>

<task type="auto">
  <name>Task 2: Implement init command</name>
  <files>
    packages/arios-cli/src/commands/init.ts
    packages/arios-cli/src/index.ts
  </files>
  <action>
Implement the main `arios init` command:

**src/commands/init.ts:**

1. Import dependencies: chalk, ora, path utilities, file utils, template utils
2. Export async function `init()` that:

   a. **Check if already initialized:**
      - If .arios/ exists, show warning "ARIOS already initialized" and exit

   b. **Detect project info:**
      - Get project name from package.json name field, or directory name as fallback
      - Check if TypeScript (tsconfig.json exists)
      - Note: Full stack detection happens in /arios:start, keep this minimal

   c. **Copy static templates:**
      - Use ora spinner with message "Installing ARIOS..."
      - Copy templates/.arios/ to .arios/ (excluding .hbs files)
      - Copy templates/.claude/commands/arios/ to .claude/commands/arios/

   d. **Render templated files:**
      - Render config.json.hbs to .arios/config.json with { projectName, typescript, version: "0.1.0" }

   e. **Update CLAUDE.md:**
      - If CLAUDE.md doesn't exist: render CLAUDE.md.hbs as new file
      - If CLAUDE.md exists but no ARIOS section: append ARIOS section
      - If CLAUDE.md exists with ARIOS section: skip (already configured)
      - ARIOS section marker: `<!-- ARIOS:START -->` and `<!-- ARIOS:END -->`

   f. **Success message:**
      - Stop spinner with success
      - Print: "ARIOS installed successfully!"
      - Print: "Run /arios:start in Claude Code to complete setup"
      - Use chalk.green for success, chalk.cyan for the command hint

**src/index.ts:**
- Update the placeholder init command to import and call the real init function
- Keep update command as placeholder for now

Handle errors: wrap main logic in try/catch, show chalk.red error message, process.exit(1).
  </action>
  <verify>
    - src/commands/init.ts exports init function
    - src/index.ts imports and uses init
    - Build succeeds: cd packages/arios-cli && npm install && npm run build
    - Manual test: node dist/index.js init (should work in test directory)
  </verify>
  <done>Init command creates .arios/, .claude/commands/arios/, updates CLAUDE.md</done>
</task>

<task type="auto">
  <name>Task 3: Implement update command placeholder</name>
  <files>
    packages/arios-cli/src/commands/update.ts
    packages/arios-cli/src/index.ts
  </files>
  <action>
Create a placeholder update command that shows what it will do:

**src/commands/update.ts:**

1. Export async function `update()` that:
   a. Check if ARIOS is installed (.arios/ exists), if not show error
   b. Read current version from .arios/config.json
   c. Print message: "Update checking is not yet implemented"
   d. Print: "Current version: {version}"
   e. Print: "Check https://github.com/[repo] for updates"

This is a stub - full implementation comes when ARIOS is published. The structure is here so users know the command exists.

**src/index.ts:**
- Update placeholder update command to import and call real update function
  </action>
  <verify>
    - src/commands/update.ts exports update function
    - src/index.ts imports and uses update
    - Running `node dist/index.js update` shows placeholder message
  </verify>
  <done>Update command placeholder ready, structure in place for future implementation</done>
</task>

</tasks>

<verification>
After all tasks complete, perform end-to-end test:

1. Build the CLI: `cd packages/arios-cli && npm run build`
2. Create test directory: `mkdir /tmp/arios-test && cd /tmp/arios-test`
3. Run init: `node /path/to/packages/arios-cli/dist/index.js init`
4. Verify created files:
   - .arios/system.md exists
   - .arios/config.json exists with project name
   - .claude/commands/arios/start.md exists
   - .claude/commands/arios/update.md exists
   - CLAUDE.md exists with ARIOS section
5. Run init again: should show "already initialized" warning
6. Run update: should show placeholder message with version
</verification>

<success_criteria>
- `npx arios init` (or direct node execution) successfully creates all ARIOS files
- Running init twice doesn't duplicate ARIOS section in CLAUDE.md
- Clear user feedback with spinners and colored output
- CLI exits cleanly with appropriate exit codes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
