---
phase: 05-execution-flow
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/arios-cli/src/quality/pattern-extractor.ts
  - packages/arios-cli/src/quality/enforcement.ts
  - packages/arios-cli/src/types/quality.ts
autonomous: true

must_haves:
  truths:
    - "Generated code follows best practices and matches existing codebase patterns"
    - "Pattern extraction identifies naming, indentation, quotes, semicolons from existing code"
    - "Patterns can be passed to executor context for style consistency"
  artifacts:
    - path: "packages/arios-cli/src/quality/pattern-extractor.ts"
      provides: "Pattern extraction from codebase"
      exports: ["extractPatterns", "CodebasePatterns"]
    - path: "packages/arios-cli/src/quality/enforcement.ts"
      provides: "Quality enforcement validation"
      exports: ["validateQuality", "QualityResult"]
    - path: "packages/arios-cli/src/types/quality.ts"
      provides: "Quality type definitions"
      exports: ["CodebasePatterns", "QualityResult", "QualityConfig"]
  key_links:
    - from: "pattern-extractor.ts"
      to: "types/quality.ts"
      via: "import"
      pattern: "import.*from.*types/quality"
    - from: "enforcement.ts"
      to: "types/quality.ts"
      via: "import"
      pattern: "import.*from.*types/quality"
---

<objective>
Create code pattern extraction and quality enforcement modules.

Purpose: Ensure generated code matches existing codebase patterns. Per Success Criterion 4: "Generated code follows best practices and matches existing codebase patterns". Per RESEARCH.md Pitfall #6: "Extract patterns from existing code, include in executor context, enforce via linting."
Output: TypeScript modules for pattern extraction and quality validation.
</objective>

<execution_context>
@/Users/j.franke/.claude/get-shit-done/workflows/execute-plan.md
@/Users/j.franke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-execution-flow/05-CONTEXT.md
@.planning/phases/05-execution-flow/05-RESEARCH.md

# Existing patterns
@packages/arios-cli/src/utils/state.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create quality types</name>
  <files>packages/arios-cli/src/types/quality.ts</files>
  <action>
Create TypeScript type definitions for quality enforcement:

1. `CodebasePatterns` - type alias with fields:
   - namingConventions: { files: string, functions: string, components: string }
   - importStyle: string (e.g., "named imports", "default imports")
   - exportStyle: string (e.g., "named exports", "default exports")
   - indentation: string (e.g., "2 spaces", "tabs")
   - quotes: 'single' | 'double'
   - semicolons: boolean
   - examples: { component?: string, function?: string, api?: string }

2. `QualityConfig` - type alias with fields:
   - projectDir: string
   - srcDirs: string[] (directories to analyze, e.g., ["src"])
   - sampleLimit: number (max files to analyze, default 5)

3. `QualityResult` - type alias with fields:
   - patterns: CodebasePatterns
   - analyzed: number (files analyzed)
   - confidence: 'high' | 'medium' | 'low' (based on sample size and consistency)

Follow existing type patterns from types/state.ts with JSDoc comments.
  </action>
  <verify>npx tsc --noEmit packages/arios-cli/src/types/quality.ts</verify>
  <done>CodebasePatterns, QualityConfig, QualityResult types compile and export</done>
</task>

<task type="auto">
  <name>Task 2: Implement pattern extraction</name>
  <files>packages/arios-cli/src/quality/pattern-extractor.ts</files>
  <action>
Create pattern extraction module (based on RESEARCH.md extractPatterns example):

1. Imports:
   - fs from 'fs-extra'
   - path from 'node:path'
   - Types from '../types/quality.js'

2. `extractPatterns(config: QualityConfig): Promise<QualityResult>` function:

   a. Initialize patterns with defaults:
      - namingConventions: { files: 'unknown', functions: 'unknown', components: 'unknown' }
      - importStyle: 'unknown'
      - exportStyle: 'unknown'
      - indentation: 'unknown'
      - quotes: 'single'
      - semicolons: true
      - examples: {}

   b. Find sample TypeScript/TSX files in srcDirs:
      - Use recursive file search (internal helper)
      - Skip node_modules, .git, dist directories
      - Limit to config.sampleLimit files

   c. For each sample file, analyze:
      - Indentation: detect tabs vs spaces (match /^( +|\t)/m)
      - Quotes: count single vs double quotes
      - Semicolons: check if lines end with semicolons
      - Store first component example (for .tsx files)
      - Store first function example (for .ts files)

   d. Calculate confidence:
      - high: analyzed >= 5 files with consistent patterns
      - medium: analyzed 2-4 files
      - low: analyzed 0-1 files

   e. Return QualityResult

3. `findFiles(dir: string, extensions: string[], limit: number): Promise<string[]>` (internal helper):
   - Recursive file search
   - Filter by extensions (.ts, .tsx)
   - Skip common ignored directories
   - Return up to limit files

Per RESEARCH.md: "Start simple: indentation, quotes, semicolons, one example of each file type. Expand if quality issues arise."
  </action>
  <verify>npx tsc --noEmit packages/arios-cli/src/quality/pattern-extractor.ts</verify>
  <done>extractPatterns function compiles and returns CodebasePatterns with detected values</done>
</task>

<task type="auto">
  <name>Task 3: Implement quality validation</name>
  <files>packages/arios-cli/src/quality/enforcement.ts</files>
  <action>
Create quality validation module:

1. Imports:
   - Types from '../types/quality.js'
   - extractPatterns from './pattern-extractor.js'

2. `validateQuality(config: QualityConfig): Promise<QualityResult>`:
   - Wrapper around extractPatterns that returns full QualityResult
   - This function is the public API used by executor context

3. `formatPatternsForPrompt(patterns: CodebasePatterns): string`:
   - Format patterns as text suitable for including in executor prompts
   - Example output:
     ```
     Code Style:
     - Indentation: 2 spaces
     - Quotes: single
     - Semicolons: yes

     Example component:
     [first 200 chars of example]
     ```
   - This enables executor to match existing codebase style

4. `getPatternsOrDefault(projectDir: string): Promise<CodebasePatterns>`:
   - Try to extract patterns from project
   - If no files found, return sensible defaults (2 spaces, single quotes, semicolons)
   - Used when starting new projects with no existing code

Per RESEARCH.md Pitfall #6: "Extract patterns from existing code, include in executor context, enforce via linting."
Per CONTEXT.md decisions: Code quality enforcement uses existing tools, pattern matching uses grep-based extraction.
  </action>
  <verify>npx tsc --noEmit packages/arios-cli/src/quality/enforcement.ts</verify>
  <done>validateQuality and formatPatternsForPrompt functions compile and export</done>
</task>

</tasks>

<verification>
Run TypeScript compilation:
```bash
cd packages/arios-cli && npx tsc --noEmit
```
All files should compile without errors.
</verification>

<success_criteria>
- extractPatterns analyzes existing code and returns detected patterns
- Patterns include indentation, quotes, semicolons, and examples
- formatPatternsForPrompt generates text suitable for executor prompts
- Confidence level reflects sample size and consistency
- Works on projects with no existing code (returns defaults)
</success_criteria>

<output>
After completion, create `.planning/phases/05-execution-flow/05-05-SUMMARY.md`
</output>
