---
phase: 05-execution-flow
plan: 09
type: execute
wave: 2
depends_on: ["05-07"]
files_modified:
  - packages/arios-cli/templates/.claude/commands/arios/orchestrate.md
  - packages/arios-cli/templates/.claude/commands/arios/execute.md
autonomous: false
gap_closure: true

must_haves:
  truths:
    - "After each wave, Claude runs checkpoint verification using Bash tool"
    - "User is prompted on checkpoint failure with re-verify/skip/abort options"
    - "Execution only continues if checkpoint passes or user skips"
  artifacts:
    - path: "packages/arios-cli/templates/.claude/commands/arios/orchestrate.md"
      provides: "Checkpoint verification after wave"
      contains: "Bash tool|startCommand|testCommand|run_in_background"
    - path: "packages/arios-cli/templates/.claude/commands/arios/execute.md"
      provides: "Checkpoint config per project"
      contains: "startCommand|testCommand|checkpoint"
  key_links:
    - from: "orchestrate.md"
      to: "Bash tool"
      via: "shell command execution for checkpoint"
      pattern: "Bash tool|run_in_background|timeout"
    - from: "execute.md"
      to: ".planning/config.json"
      via: "checkpoint configuration documentation"
      pattern: "startCommand|testCommand|checkpoint"
---

<objective>
Wire checkpoint verification into execution flow with user pause.

Purpose: Close gap where verifyCheckpoint exists but is never called. Execution should pause at testable points where user can verify the app works.

Output: Updated orchestrate.md and execute.md with checkpoint verification flow.
</objective>

<execution_context>
@/Users/j.franke/.claude/get-shit-done/workflows/execute-plan.md
@/Users/j.franke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/arios-cli/templates/.claude/commands/arios/orchestrate.md
@packages/arios-cli/templates/.claude/commands/arios/execute.md
@packages/arios-cli/src/execution/checkpoint.ts
@.planning/phases/05-execution-flow/05-07-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add checkpoint config to execute command</name>
  <files>packages/arios-cli/templates/.claude/commands/arios/execute.md</files>
  <action>
Update /arios:execute to support checkpoint configuration:

1. Update Variables section:
   Add checkpoint config reference:
   ```
   **Static:** .planning/STATE.md, .planning/config.json, .planning/roadmaps/

   Checkpoint config (in .planning/config.json):
   - startCommand: Command to start the app (e.g., "npm run dev")
   - startReadyPattern: Regex to detect app is ready (e.g., "ready on|listening on")
   - testCommand: Command to run tests (e.g., "npm test")
   - startTimeout: Timeout for app start (default: 30000ms)
   - testTimeout: Timeout for tests (default: 120000ms)
   ```

2. Add to Instructions section:
   - After each wave, run checkpoint verification if configured
   - Checkpoint passes when: app runs successfully AND tests pass
   - Missing config = skip verification (nothing to verify)
   - On checkpoint failure: pause and show diagnostic, ask user to fix or continue

3. Update Workflow section after step 7 (Route to orchestrator):
   Insert new step 8: "Checkpoint verification"
   - If checkpoint config exists in .planning/config.json:
     * Run startCommand, wait for readyPattern or timeout
     * If app starts: run testCommand, check exit code
     * Display result: "Checkpoint: PASSED" or "Checkpoint: FAILED"
   - If no config: skip checkpoint (greenfield/early stages)

4. Update Report section:
   Add checkpoint status:
   ```
   Checkpoint: {PASSED|FAILED|SKIPPED}
   - App starts: {yes|no|n/a}
   - Tests pass: {yes|no|n/a}
   ```
  </action>
  <verify>
Read updated execute.md and confirm:
- Checkpoint config documented in Variables
- Checkpoint step in Workflow after orchestrator routing
- Checkpoint status in Report section
  </verify>
  <done>
execute.md includes checkpoint configuration and verification step
  </done>
</task>

<task type="auto">
  <name>Task 2: Add checkpoint verification to orchestrate command</name>
  <files>packages/arios-cli/templates/.claude/commands/arios/orchestrate.md</files>
  <action>
Update /arios:orchestrate to run checkpoint after each wave:

1. Update Workflow section, execution flow (step 5):
   After wave completion, add checkpoint verification:
   ```
   5. If execution needed:
      a. Build wave schedule from phase plan frontmatter
      b. For each wave in order:
         - Spawn executor(s) for plans in this wave
         - Wait for wave completion
         - **Run checkpoint verification (using Bash tool - see below)**
         - Report wave + checkpoint status
   ```

2. Add checkpoint section to Spawn Patterns with EXPLICIT Bash tool instructions:
   ```
   **Checkpoint Verification (CRITICAL - use Bash tool):**
   After each wave completes:

   1. Use Read tool on .planning/config.json for checkpoint config:
      ```json
      {
        "checkpoint": {
          "startCommand": "npm run dev",
          "startReadyPattern": "ready on|listening on",
          "testCommand": "npm test",
          "startTimeout": 30000,
          "testTimeout": 120000
        }
      }
      ```

   2. If checkpoint config exists:

      a. **Start the app using Bash tool with background flag:**
         ```
         Use Bash tool:
         command: "{startCommand}"
         run_in_background: true
         timeout: {startTimeout}
         ```

      b. **Wait for ready pattern using Bash tool:**
         ```
         Use Bash tool (with short timeout, repeat if needed):
         command: "curl -s http://localhost:3000 || echo 'not ready'"
         ```
         OR watch process output for readyPattern match

      c. **If app ready, run tests using Bash tool:**
         ```
         Use Bash tool:
         command: "{testCommand}"
         timeout: {testTimeout}
         ```

      d. **Check exit code:**
         - Exit code 0 = tests pass
         - Non-zero exit code = tests fail

      e. **Determine result:**
         passed = appStarted AND testsPass

      f. **Clean up - kill background process:**
         ```
         Use Bash tool:
         command: "pkill -f '{startCommand}' || true"
         ```

   3. If checkpoint fails:
      - Display diagnostic: what failed (start or tests) and error output
      - Prompt user: "Fix the issue and press Enter to re-verify, or type 'skip' to continue"
      - If re-verify: repeat steps 2a-2f
      - If skip: log warning and continue

   4. If no checkpoint config: checkpoint skipped (assume passed)
   ```

3. Add checkpoint status to Report section:
   ```
   ### Checkpoint Status
   Wave 1: PASSED (app: ok, tests: ok)
   Wave 2: PASSED (app: ok, tests: ok)
   Wave 3: FAILED (app: ok, tests: failed)
           Error: 3 tests failed (see output above)
           Action needed: Fix failing tests before continuing
   ```

4. Add user interaction on failure:
   Document the pause-and-prompt behavior:
   - Show detailed failure output from Bash tool
   - Ask: "Fix issues and re-verify (Enter), skip (s), or abort (a)?"
   - Handle each option appropriately

**Execution mechanism (ADDRESSES BLOCKER):**
- orchestrate.md is a markdown command that instructs Claude
- Claude has access to Bash tool for running shell commands
- The template tells Claude WHEN and HOW to use Bash tool:
  * Bash tool with run_in_background: true for startCommand
  * Bash tool with timeout for testCommand
  * Check exit codes from Bash tool output
- No TypeScript imports needed - Claude runs commands directly
  </action>
  <verify>
Read updated orchestrate.md and confirm:
- Checkpoint verification specifies using Bash tool
- Start command uses run_in_background: true
- Test command uses Bash tool with timeout
- Exit code checking documented
- Background process cleanup documented
- User interaction documented for failures
  </verify>
  <done>
orchestrate.md runs checkpoint using Bash tool after each wave with explicit execution mechanism
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Checkpoint verification flow wired into execute and orchestrate commands
  </what-built>
  <how-to-verify>
1. Read packages/arios-cli/templates/.claude/commands/arios/execute.md
   - Confirm checkpoint config documented
   - Confirm checkpoint step in workflow

2. Read packages/arios-cli/templates/.claude/commands/arios/orchestrate.md
   - Confirm checkpoint runs after each wave
   - Confirm user prompt on failure documented
   - Confirm checkpoint status in report

3. Verify the flow makes sense:
   - Wave completes → checkpoint runs → pass = continue, fail = prompt user
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. Read both command files
2. Verify checkpoint verification is wired after wave completion
3. Verify user interaction on failure is documented
4. Verify checkpoint config location and format documented
5. Verify checkpoint status appears in reports
</verification>

<success_criteria>
- Checkpoint runs automatically after each wave
- User is informed of checkpoint status (pass/fail/skip)
- Failed checkpoints pause execution and prompt user
- User can re-verify, skip, or abort
- Checkpoint config is documented and discoverable
</success_criteria>

<output>
After completion, create `.planning/phases/05-execution-flow/05-09-SUMMARY.md`
</output>
