---
phase: 05-execution-flow
plan: 04
type: execute
wave: 2
depends_on: ["05-02"]
files_modified:
  - packages/arios-cli/src/execution/recovery.ts
  - packages/arios-cli/src/types/execution.ts
autonomous: true

must_haves:
  truths:
    - "Checkpoint failure triggers debug subagent"
    - "Recovery attempts limited to 2-3 retries"
    - "Retries exhausted produces diagnostic output"
  artifacts:
    - path: "packages/arios-cli/src/execution/recovery.ts"
      provides: "Recovery flow with retry logic"
      exports: ["attemptRecovery", "RecoveryResult"]
    - path: "packages/arios-cli/src/types/execution.ts"
      provides: "Recovery type definitions"
      exports: ["RecoveryAttempt", "RecoveryResult"]
  key_links:
    - from: "recovery.ts"
      to: "types/execution.ts"
      via: "import CheckpointResult type"
      pattern: "import.*CheckpointResult.*from.*types/execution"
    - from: "recovery.ts"
      to: "checkpoint.ts"
      via: "import verifyCheckpoint function"
      pattern: "import.*verifyCheckpoint.*from.*checkpoint"
---

<objective>
Create recovery flow module for checkpoint failures and integration conflicts.

Purpose: When checkpoints fail, spawn debug subagent that writes debug plan, executor runs it. Per CONTEXT.md: "2-3 attempts before hard stop, then stop with diagnostic output".
Output: TypeScript module for recovery flow with bounded retries.

Note: The stub functions (spawnDebugSubagent, executeDebugPlan) will be wired to the orchestrator when execution commands are implemented in Phase 5 integration work. This plan establishes the interface and recovery logic; actual subagent invocation is deferred.
</objective>

<execution_context>
@/Users/j.franke/.claude/get-shit-done/workflows/execute-plan.md
@/Users/j.franke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-execution-flow/05-CONTEXT.md
@.planning/phases/05-execution-flow/05-RESEARCH.md

# Checkpoint types from 05-02
@packages/arios-cli/src/types/execution.ts
@packages/arios-cli/src/execution/checkpoint.ts

# Existing subagent patterns
@packages/arios-cli/templates/.claude/agents/executor.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add recovery types to execution types</name>
  <files>packages/arios-cli/src/types/execution.ts</files>
  <action>
Add recovery-related types to the existing execution.ts file:

1. `RecoveryAttempt` - type alias with fields:
   - attempt: number (1, 2, 3)
   - diagnosis: string (summary of what debug subagent found)
   - debugPlanPath: string (path to debug plan written)
   - result: 'fixed' | 'failed'

2. `RecoveryResult` - type alias with fields:
   - fixed: boolean (true if recovery succeeded)
   - attempts: RecoveryAttempt[]
   - finalDiagnostic?: string (if retries exhausted, diagnostic output)

3. `RecoveryConfig` - type alias with fields:
   - maxAttempts: number (default: 3 per CONTEXT.md "2-3 attempts")
   - checkpointConfig: CheckpointConfig (for re-verification)

Follow existing type patterns with JSDoc comments.
  </action>
  <verify>npx tsc --noEmit packages/arios-cli/src/types/execution.ts</verify>
  <done>RecoveryAttempt, RecoveryResult, and RecoveryConfig types compile and export</done>
</task>

<task type="auto">
  <name>Task 2: Implement recovery flow</name>
  <files>packages/arios-cli/src/execution/recovery.ts</files>
  <action>
Create recovery flow module:

1. Imports:
   - Types from '../types/execution.js' (CheckpointResult, RecoveryConfig, RecoveryAttempt, RecoveryResult)
   - verifyCheckpoint from './checkpoint.js'
   - fs from 'fs-extra'
   - path from 'node:path'

2. `attemptRecovery(cwd: string, failure: CheckpointResult, config: RecoveryConfig): Promise<RecoveryResult>` function:

   a. Initialize result: { fixed: false, attempts: [] }

   b. Loop for config.maxAttempts (default 3):
      - Create RecoveryAttempt for this iteration
      - Call spawnDebugSubagent (stub for now - returns diagnosis and planPath)
      - Record attempt.diagnosis and attempt.debugPlanPath
      - Call executeDebugPlan (stub - returns success boolean)
      - If success: re-verify with verifyCheckpoint
      - If passed: set fixed=true, return result
      - Otherwise: record attempt.result = 'failed', continue

   c. If loop completes without fix:
      - Generate finalDiagnostic from all attempts
      - Return result with fixed=false

3. `spawnDebugSubagent(cwd: string, failure: CheckpointResult): Promise<{diagnosis: string, planPath: string}>` (stub):
   - For now: return placeholder values
   - TODO: Wire to Task tool to spawn debug agent when orchestrator commands implemented
   - Debug agent writes plan to .planning/debug/debug-{timestamp}-PLAN.md

4. `executeDebugPlan(planPath: string): Promise<{success: boolean}>` (stub):
   - For now: return { success: false }
   - TODO: Wire to executor invocation when orchestrator commands implemented

5. `generateDiagnostic(attempts: RecoveryAttempt[]): string`:
   - Format diagnostic output showing all attempts
   - Include: attempt number, diagnosis, result
   - End with suggestion to check manually

Per CONTEXT.md:
- "2-3 attempts before hard stop" -> maxAttempts: 3
- "Stop with diagnostic output" -> generateDiagnostic
- "Debug subagent writes debug plan, executor runs it" -> spawnDebugSubagent + executeDebugPlan pattern

Per RESEARCH.md pitfall #3: "Per CONTEXT.md: 2-3 retry limit, then hard stop with diagnostic output"
  </action>
  <verify>npx tsc --noEmit packages/arios-cli/src/execution/recovery.ts</verify>
  <done>attemptRecovery function compiles, respects maxAttempts limit, generates diagnostic on failure</done>
</task>

</tasks>

<verification>
Run TypeScript compilation:
```bash
cd packages/arios-cli && npx tsc --noEmit
```
All files should compile without errors.
</verification>

<success_criteria>
- attemptRecovery stops after maxAttempts iterations
- Each attempt is recorded in RecoveryResult.attempts array
- finalDiagnostic generated when retries exhausted
- Re-verification happens after each debug plan execution
- Stub functions clearly marked with TODO for future implementation
</success_criteria>

<output>
After completion, create `.planning/phases/05-execution-flow/05-04-SUMMARY.md`
</output>
