---
phase: 05-execution-flow
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/arios-cli/src/config/approach.ts
  - packages/arios-cli/src/types/config.ts
autonomous: true

must_haves:
  truths:
    - "User can select approach at project start (ground-up/balanced/ui-first)"
    - "Selected approach persists across sessions"
    - "Approach defaults to balanced if not set"
  artifacts:
    - path: "packages/arios-cli/src/config/approach.ts"
      provides: "Approach selection and storage"
      exports: ["getApproach", "setApproach", "getApproachGuidance", "Approach"]
    - path: "packages/arios-cli/src/types/config.ts"
      provides: "Config type definitions"
      exports: ["Approach", "ProjectConfig"]
  key_links:
    - from: "approach.ts"
      to: "types/config.ts"
      via: "import"
      pattern: "import.*from.*types/config"
---

<objective>
Create approach selection and configuration storage for project development style.

Purpose: Enable user to choose ground-up, balanced, or UI-first approach at project start. Per CONTEXT.md: "Offered at project start only, user can change only by explicit request".
Output: TypeScript module for approach selection with persistent storage.
</objective>

<execution_context>
@/Users/j.franke/.claude/get-shit-done/workflows/execute-plan.md
@/Users/j.franke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-execution-flow/05-CONTEXT.md
@.planning/phases/05-execution-flow/05-RESEARCH.md

# Existing patterns
@packages/arios-cli/src/utils/state.ts
@packages/arios-cli/src/types/state.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create config types</name>
  <files>packages/arios-cli/src/types/config.ts</files>
  <action>
Create TypeScript type definitions for project configuration:

1. `Approach` - type alias: 'ground-up' | 'balanced' | 'ui-first'

2. `ProjectConfig` - type alias with fields:
   - approach: Approach
   - approachSetAt: string (ISO date when approach was set)

Per CONTEXT.md approach definitions:
- balanced (default): interleave UI and logic as needed
- ground-up: Claude interprets per project domain (data layer first)
- ui-first: mockup with stubs first, then wire real logic

Follow existing type patterns from types/state.ts with JSDoc comments.
  </action>
  <verify>npx tsc --noEmit packages/arios-cli/src/types/config.ts</verify>
  <done>Approach and ProjectConfig types compile and export</done>
</task>

<task type="auto">
  <name>Task 2: Implement approach selection</name>
  <files>packages/arios-cli/src/config/approach.ts</files>
  <action>
Create approach selection module using file-based storage (not conf library - keep it simple like state.ts):

1. Imports:
   - fs from 'fs-extra'
   - path from 'node:path'
   - Types from '../types/config.js'

2. Config file location: `.planning/config.json` (project-local per RESEARCH.md anti-pattern)

3. `loadConfig(projectDir: string): Promise<ProjectConfig>` (internal helper):
   - Read .planning/config.json
   - Return defaults if not exists: { approach: 'balanced', approachSetAt: '' }

4. `saveConfig(projectDir: string, config: ProjectConfig): Promise<void>` (internal helper):
   - Write to .planning/config.json
   - Ensure .planning directory exists

5. `getApproach(projectDir: string): Promise<Approach>`:
   - Load config and return approach
   - Default to 'balanced'

6. `setApproach(projectDir: string, approach: Approach): Promise<void>`:
   - Load existing config
   - Update approach and approachSetAt
   - Save config

7. `hasApproachSet(projectDir: string): Promise<boolean>`:
   - Check if approach was explicitly set (approachSetAt not empty)
   - Used to determine if we should offer selection at project start

8. `getApproachGuidance(approach: Approach, projectType?: string): string`:
   - Return guidance string per RESEARCH.md:
     - balanced: "Interleave UI and logic as each feature requires"
     - ground-up: varies by projectType (api/backend, fullstack, default)
     - ui-first: "Visual mockups with stub data -> Wire real API calls -> Implement backend"

Per CONTEXT.md: "Offered at project start only" - hasApproachSet enables this check.
Per RESEARCH.md anti-pattern: "Storing approach globally" - store in project config, not user preferences.
  </action>
  <verify>npx tsc --noEmit packages/arios-cli/src/config/approach.ts</verify>
  <done>Approach functions compile, getApproach returns 'balanced' by default, setApproach persists to file</done>
</task>

</tasks>

<verification>
Run TypeScript compilation:
```bash
cd packages/arios-cli && npx tsc --noEmit
```
All files should compile without errors.
</verification>

<success_criteria>
- getApproach returns 'balanced' when no config exists
- setApproach writes to .planning/config.json
- hasApproachSet returns false for new projects, true after setApproach called
- getApproachGuidance returns appropriate guidance per approach type
- Config is project-local (in .planning/), not global
</success_criteria>

<output>
After completion, create `.planning/phases/05-execution-flow/05-03-SUMMARY.md`
</output>
