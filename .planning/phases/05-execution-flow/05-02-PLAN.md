---
phase: 05-execution-flow
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - packages/arios-cli/src/execution/checkpoint.ts
  - packages/arios-cli/src/types/execution.ts
autonomous: true

must_haves:
  truths:
    - "Checkpoint verifies app runs successfully"
    - "Checkpoint verifies tests pass"
    - "Checkpoint result indicates passed = appRuns AND testsPass"
  artifacts:
    - path: "packages/arios-cli/src/execution/checkpoint.ts"
      provides: "Checkpoint verification logic"
      exports: ["verifyCheckpoint", "CheckpointResult"]
    - path: "packages/arios-cli/src/types/execution.ts"
      provides: "Checkpoint type definitions"
      exports: ["CheckpointConfig", "CheckpointResult"]
  key_links:
    - from: "checkpoint.ts"
      to: "types/execution.ts"
      via: "import"
      pattern: "import.*from.*types/execution"
---

<objective>
Create testable checkpoint verification module.

Purpose: Enable execution to pause at points where user can verify the app works. Per CONTEXT.md: "Testable = app runs + tests pass".
Output: TypeScript module for checkpoint verification with configurable commands and timeouts.
</objective>

<execution_context>
@/Users/j.franke/.claude/get-shit-done/workflows/execute-plan.md
@/Users/j.franke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-execution-flow/05-CONTEXT.md
@.planning/phases/05-execution-flow/05-RESEARCH.md

# Types created in 05-01
@packages/arios-cli/src/types/execution.ts

# Existing patterns
@packages/arios-cli/src/utils/handoff.ts
@packages/arios-cli/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add checkpoint types to execution types</name>
  <files>packages/arios-cli/src/types/execution.ts</files>
  <action>
Add checkpoint-related types to the existing execution.ts file (created in 05-01):

1. `CheckpointConfig` - type alias with fields:
   - startCommand?: string (e.g., "npm run dev")
   - startReadyPattern?: string (regex pattern as string, e.g., "ready on port")
   - startTimeout?: number (ms, default concept: 30000)
   - testCommand?: string (e.g., "npm test")
   - testTimeout?: number (ms, default concept: 120000)

2. `CheckpointResult` - type alias with fields:
   - appRuns: boolean
   - testsPass: boolean
   - passed: boolean (appRuns AND testsPass per CONTEXT.md)
   - output: string (combined output for logging)
   - errors: string[] (any error messages)

The file should already exist with ComplexityLevel, PlanMeta, ComplexityResult, WaveSchedule from 05-01.
Append these new types, maintaining the existing JSDoc and export patterns.

Follow existing type patterns with JSDoc comments.
  </action>
  <verify>npx tsc --noEmit packages/arios-cli/src/types/execution.ts</verify>
  <done>CheckpointConfig and CheckpointResult types compile and export, file contains all types from 05-01 plus new checkpoint types</done>
</task>

<task type="auto">
  <name>Task 2: Implement checkpoint verification</name>
  <files>packages/arios-cli/src/execution/checkpoint.ts</files>
  <action>
Create checkpoint verification module:

1. Imports:
   - `spawn` from 'node:child_process'
   - Types from '../types/execution.js'

2. `verifyCheckpoint(cwd: string, config: CheckpointConfig): Promise<CheckpointResult>` function:

   a. Initialize result with appRuns: true, testsPass: true (assume passing if not configured)

   b. If config.startCommand exists:
      - Spawn process with command
      - Wait for startReadyPattern match in stdout OR timeout
      - Kill process after ready signal or timeout
      - Set appRuns = true if ready pattern matched, false if timeout/error
      - Collect output/errors

   c. If config.testCommand exists AND appRuns is true:
      - Spawn process with test command
      - Wait for exit with timeout
      - Set testsPass = (exitCode === 0)
      - Collect output/errors

   d. Set passed = appRuns AND testsPass (per CONTEXT.md "testable = app runs + tests pass")

   e. Return CheckpointResult

Implementation notes:
- Use node:child_process spawn (not execa - keep dependencies minimal)
- Handle process cleanup on timeout
- Default timeouts: start=30000ms, test=120000ms
- Graceful error handling (catch and record, don't throw)

Per RESEARCH.md pitfall #2: "Configurable timeouts, graceful handling of slow starts, clear error messages"
  </action>
  <verify>npx tsc --noEmit packages/arios-cli/src/execution/checkpoint.ts</verify>
  <done>verifyCheckpoint function compiles, handles both app start and test verification</done>
</task>

</tasks>

<verification>
Run TypeScript compilation:
```bash
cd packages/arios-cli && npx tsc --noEmit
```
All files should compile without errors.
</verification>

<success_criteria>
- verifyCheckpoint returns passed: true only when BOTH appRuns AND testsPass are true
- Missing config.startCommand -> appRuns defaults to true (no app to run)
- Missing config.testCommand -> testsPass defaults to true (no tests configured)
- Timeouts are handled gracefully without hanging
- Errors are collected in errors array, not thrown
</success_criteria>

<output>
After completion, create `.planning/phases/05-execution-flow/05-02-SUMMARY.md`
</output>
