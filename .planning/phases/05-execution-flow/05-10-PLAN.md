---
phase: 05-execution-flow
plan: 10
type: execute
wave: 3
depends_on: ["05-09"]
files_modified:
  - packages/arios-cli/templates/.claude/commands/arios/orchestrate.md
  - packages/arios-cli/templates/.claude/agents/executor.md
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Checkpoint failures trigger recovery flow with debug subagent"
    - "Recovery attempts bounded retry (max 3 attempts)"
    - "After recovery exhausted, execution stops with diagnostic output"
  artifacts:
    - path: "packages/arios-cli/templates/.claude/commands/arios/orchestrate.md"
      provides: "Recovery flow orchestration"
      contains: "attemptRecovery|debug"
  key_links:
    - from: "orchestrate.md"
      to: "recovery.ts"
      via: "attemptRecovery call instruction"
      pattern: "attemptRecovery|recovery|debug"
    - from: "orchestrate.md"
      to: "executor.md"
      via: "debug plan execution"
      pattern: "debug.*plan|fix.*attempt"
---

<objective>
Wire recovery flow into checkpoint failures with debug subagent.

Purpose: Close gap where attemptRecovery exists but checkpoint never fails because it's never called. When checkpoints fail, recovery should spawn debug subagent to diagnose and fix.

Output: Updated orchestrate.md with recovery flow on checkpoint failure.
</objective>

<execution_context>
@/Users/j.franke/.claude/get-shit-done/workflows/execute-plan.md
@/Users/j.franke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/arios-cli/templates/.claude/commands/arios/orchestrate.md
@packages/arios-cli/templates/.claude/agents/executor.md
@packages/arios-cli/src/execution/recovery.ts
@.planning/phases/05-execution-flow/05-09-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add recovery flow to orchestrator</name>
  <files>packages/arios-cli/templates/.claude/commands/arios/orchestrate.md</files>
  <action>
Update /arios:orchestrate to handle checkpoint failures with recovery:

1. Update Workflow section, checkpoint failure handling:
   Replace simple "prompt user" with recovery flow:
   ```
   If checkpoint fails:
   a. **Attempt automatic recovery (max 3 attempts):**
      For attempt 1 to 3:
        i.   Spawn debug subagent to diagnose failure
        ii.  Debug subagent writes diagnosis and fix plan to .planning/debug/
        iii. Execute the debug plan (spawn executor)
        iv.  Re-run checkpoint verification
        v.   If checkpoint passes: recovery succeeded, continue to next wave
        vi.  If checkpoint fails: increment attempt, try again

   b. **If all attempts exhausted:**
      - Generate diagnostic output summarizing all attempts
      - Stop execution with error:
        "Recovery failed after 3 attempts. Manual fix required."
      - Show diagnostic with:
        * What failed (app start vs tests)
        * Each attempt's diagnosis
        * Each debug plan tried
        * Recommendation: Check common causes
   ```

2. Add Debug Subagent section to Spawn Patterns:
   ```
   **Debug Subagent (recovery):**
   Spawned when checkpoint fails to diagnose and propose fix.

   Provide:
   - Checkpoint failure details (appRuns, testsPass, errors)
   - Recent execution output (last wave's work)
   - Error logs if available

   Output:
   - Diagnosis: Root cause analysis
   - Debug plan: .planning/debug/debug-{timestamp}-PLAN.md
     * Specific fix tasks to address the failure
     * Verification steps to confirm fix

   Debug plan format:
   ---
   type: debug
   checkpoint_failure: {app|tests|both}
   attempt: {1|2|3}
   ---

   <tasks>
   <task type="auto">
     <files>{files to fix}</files>
     <action>{specific fix}</action>
     <verify>{how to verify fix}</verify>
   </task>
   </tasks>
   ```

3. Update Report section with recovery status:
   ```
   ### Recovery Status
   Checkpoint failed at Wave 2.

   Attempt 1:
   - Diagnosis: Missing import in component.tsx
   - Debug plan: .planning/debug/debug-1706234567-PLAN.md
   - Result: Still failing (different error)

   Attempt 2:
   - Diagnosis: Type mismatch in API response
   - Debug plan: .planning/debug/debug-1706234600-PLAN.md
   - Result: ✓ Fixed - checkpoint now passes

   Continuing to Wave 3...
   ```

4. Add failure diagnostic format:
   ```
   ### Recovery Failed

   All 3 attempts exhausted. Manual investigation required.

   **Failure:** Tests failed (app starts successfully)
   **Error:** 2 tests failing in auth.test.ts

   **Attempts:**
   1. Fixed missing import → different error
   2. Fixed type mismatch → still 1 test failing
   3. Fixed edge case → still 1 test failing (same)

   **Recommendation:**
   The failing test may require architectural changes beyond
   automatic recovery. Common causes:
   - Missing dependencies
   - Configuration errors
   - Integration conflicts
   - Test environment issues

   Review .planning/debug/ for all debug plans and diagnostics.
   ```
  </action>
  <verify>
Read updated orchestrate.md and confirm:
- Recovery loop (3 attempts) documented
- Debug subagent spawn pattern documented
- Recovery status in report section
- Failure diagnostic format documented
  </verify>
  <done>
orchestrate.md includes recovery flow with bounded retry and diagnostics
  </done>
</task>

<task type="auto">
  <name>Task 2: Create debug subagent template reference</name>
  <files>packages/arios-cli/templates/.claude/agents/executor.md</files>
  <action>
Update executor.md to handle debug plans:

1. Add to <role> section:
   Append note: "Also executes debug plans generated by recovery flow."

2. Add <debug_mode> section after <problem_reporting>:
   ```
   <debug_mode>
   When executing a debug plan (type: debug in frontmatter):

   1. Focus on the specific fix described
   2. Make minimal changes - fix only what's broken
   3. Do NOT refactor or improve unrelated code
   4. Verify the fix addresses the checkpoint failure
   5. Report success or continued failure honestly

   Debug plans are generated by the recovery flow to fix checkpoint
   failures. They target specific issues found by diagnosis.
   </debug_mode>
   ```

3. Update <output> section to handle debug plan results:
   Add debug-specific output format:
   ```
   ## DEBUG PLAN COMPLETE

   **Plan:** {debug plan path}
   **Target:** {what was being fixed}

   ### Fix Applied
   - {file modified}: {what changed}

   ### Verification
   - {verify command}: {result}

   ### Status
   {Fixed - checkpoint should pass | Not fixed - {reason}}
   ```
  </action>
  <verify>
Read updated executor.md and confirm:
- Debug mode section exists
- Role mentions debug plan execution
- Debug-specific output format documented
  </verify>
  <done>
executor.md can execute debug plans with appropriate constraints
  </done>
</task>

</tasks>

<verification>
1. Read packages/arios-cli/templates/.claude/commands/arios/orchestrate.md
2. Verify recovery flow with 3-attempt loop
3. Verify debug subagent spawn pattern
4. Verify diagnostic output on exhausted retries
5. Read packages/arios-cli/templates/.claude/agents/executor.md
6. Verify debug mode section exists
7. Verify debug plan output format documented
</verification>

<success_criteria>
- Checkpoint failures trigger automatic recovery (up to 3 attempts)
- Each attempt: diagnose → debug plan → execute → re-verify
- Recovery success = continue execution
- Recovery exhausted = stop with comprehensive diagnostic
- Executor can execute debug plans with minimal-change focus
- User sees recovery progress and outcomes
</success_criteria>

<output>
After completion, create `.planning/phases/05-execution-flow/05-10-SUMMARY.md`
</output>
