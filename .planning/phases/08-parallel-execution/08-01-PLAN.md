---
phase: 08-parallel-execution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/arios-cli/templates/.claude/agents/wave-executor.md
  - packages/arios-cli/templates/.claude/commands/arios/orchestrate.md
autonomous: true

must_haves:
  truths:
    - "Wave-executor receives fresh context with inlined plan content"
    - "Multiple wave-executors can spawn in parallel via concurrent Task calls"
    - "Orchestrator reads plan content before spawning (not passed as @-reference)"
  artifacts:
    - path: "packages/arios-cli/templates/.claude/agents/wave-executor.md"
      provides: "Wave-executor agent prompt"
      min_lines: 60
    - path: "packages/arios-cli/templates/.claude/commands/arios/orchestrate.md"
      provides: "Parallel orchestration logic"
      contains: "Inline plan content"
  key_links:
    - from: "orchestrate.md"
      to: "wave-executor.md"
      via: "Task tool spawning with inlined content"
      pattern: "Use Read tool.*before spawning"
---

<objective>
Create wave-executor agent and update orchestrator for true parallel execution.

Purpose: Enable wave-level parallelism where multiple wave-executors run simultaneously with fresh contexts, per CONTEXT.md decisions.

Output: wave-executor.md agent prompt, updated orchestrate.md with inlined content pattern
</objective>

<execution_context>
@/Users/j.franke/.claude/get-shit-done/workflows/execute-plan.md
@/Users/j.franke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-parallel-execution/08-CONTEXT.md
@.planning/phases/08-parallel-execution/08-RESEARCH.md
@packages/arios-cli/templates/.claude/agents/executor.md
@packages/arios-cli/templates/.claude/commands/arios/orchestrate.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create wave-executor agent prompt</name>
  <files>packages/arios-cli/templates/.claude/agents/wave-executor.md</files>
  <action>
Create the wave-executor agent that executes a single plan with fresh context.

Key characteristics from RESEARCH.md:
- Receives inlined plan content and state (not @-references)
- Executes all tasks in the plan sequentially
- Commits each task atomically: `{type}({phase}-{plan}): {task-name}`
- Creates SUMMARY.md when complete
- Returns compact completion message (5-10 lines)

Structure:
```
---
name: wave-executor
description: Executes a single plan within a wave. Spawned by orchestrator with fresh context.
tools: Read, Write, Edit, Bash, Grep, Glob
model: sonnet
---

<role>
You are an ARIOS wave-executor. You execute a single PLAN.md file atomically.

You are spawned by the orchestrator with:
- Complete plan content (inlined in your prompt)
- Project state (inlined in your prompt)

Your context is fresh (~200k tokens available). Execute the plan completely.
</role>

<context_note>
**IMPORTANT:** Content is inlined because @-references don't work across Task boundaries.
Everything you need is in this prompt - no external file loading required for plan/state.
</context_note>

<code_style>
... (copy code_style section from executor.md - patterns.json loading)
</code_style>

<workflow>
1. Parse the plan from <plan_content> section
2. Read .planning/patterns.json for code style (only file you need to read)
3. For each task in plan:
   a. Execute task actions
   b. Run verify step
   c. If verify passes: commit with format `{type}({phase}-{plan}): {task-name}`
   d. If verify fails: record failure, continue to next task
4. Create SUMMARY.md in plan directory
5. Return structured completion message
</workflow>

<output>
## PLAN COMPLETE

**Plan:** {phase}-{plan}
**Tasks:** {completed}/{total}
**Commits:** [list of commit hashes]
**SUMMARY:** {path}

OR

## PLAN FAILED

**Plan:** {phase}-{plan}
**Task:** {failed_task_number} - {name}
**Error:** {description}
**Attempt:** {N}
</output>
```

Note: This is a new agent, separate from executor.md. The existing executor.md handles wave-level execution (multiple tasks across a wave). Wave-executor handles plan-level execution (one plan's tasks) - this enables true parallelism where each plan gets its own executor.
  </action>
  <verify>cat packages/arios-cli/templates/.claude/agents/wave-executor.md && test -s packages/arios-cli/templates/.claude/agents/wave-executor.md</verify>
  <done>wave-executor.md exists with role, context_note, code_style, workflow, and output sections</done>
</task>

<task type="auto">
  <name>Task 2: Update orchestrator for inlined content pattern</name>
  <files>packages/arios-cli/templates/.claude/commands/arios/orchestrate.md</files>
  <action>
Update the orchestrator's "Spawning Executor" section for the inlined content pattern.

Key changes from RESEARCH.md:
1. Read plan content BEFORE spawning (not as @-reference in prompt)
2. Read STATE.md content BEFORE spawning
3. Inline both in the Task prompt
4. Use wave-executor.md agent instead of executor.md for parallel waves

Update the "### Spawning Executor" section:

```markdown
### Spawning Wave-Executor (Parallel Waves)

**Pre-spawn content loading (CRITICAL - @ doesn't work across Task boundaries):**
1. Use Read tool to load the plan file content
2. Use Read tool to load .planning/STATE.md content
3. These get inlined in the Task prompt below

**Display announcement:**
...

**Then use Task tool with INLINED content:**
```
Use Task tool to spawn .claude/agents/wave-executor.md

Prompt includes:
<plan_content>
{INLINED PLAN FILE CONTENT - from Read tool above}
</plan_content>

<state_content>
{INLINED STATE.MD CONTENT - from Read tool above}
</state_content>

Additional context:
- Wave number: {N}
- Patterns file: .planning/patterns.json (executor reads this itself)
```
```

Also update the "### Wave Execution Pattern" section:

```markdown
### Wave Execution Pattern

**For each wave in schedule:**
1. **Pre-load all content for this wave:**
   For each plan in wave:
   - Use Read tool to load {plan_path} content
   - Store content for inlining
   Use Read tool to load .planning/STATE.md content once

2. **Display announcements** for each executor being spawned

3. **Spawn executors:**
   If wave.canParallelize (multiple plans):
     - Spawn wave-executor for EACH plan using concurrent Task calls
     - Multiple Task calls in same message = parallel execution
     - Wait for all executors in wave to complete
   Else:
     - Spawn wave-executor for single plan
     - Wait for completion

4. **Collect results:**
   - Let all executors finish (don't stop on first failure)
   - Per CONTEXT.md: "Tasks in same wave are independent by definition"

5. **Summarize wave results** (don't show raw subagent output)

6. **Report wave completion:**
   "Wave {n}: Complete ({passed}/{total} plans)"
   If failures: list failed plans

7. **Silent verification** (Phase 9 - placeholder for now)
```

This changes the executor spawning from sequential with @-references to parallel with inlined content.
  </action>
  <verify>grep -q "Pre-spawn content loading" packages/arios-cli/templates/.claude/commands/arios/orchestrate.md && grep -q "wave-executor" packages/arios-cli/templates/.claude/commands/arios/orchestrate.md</verify>
  <done>orchestrate.md has inlined content pattern for wave-executor spawning</done>
</task>

</tasks>

<verification>
1. wave-executor.md exists and has context_note about inlined content
2. orchestrate.md references wave-executor.md (not executor.md) for parallel waves
3. orchestrate.md has "Pre-spawn content loading" section
4. No @-references to plan files in Task prompts
</verification>

<success_criteria>
- wave-executor.md created with fresh-context design
- orchestrate.md updated for inlined content pattern
- Parallel spawning pattern uses concurrent Task calls
- Both files committed
</success_criteria>

<output>
After completion, create `.planning/phases/08-parallel-execution/08-01-SUMMARY.md`
</output>
